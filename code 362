
/**
  ******************************************************************************
  * @file    main.c
  * @author  Weili An, Niraj Menon
  * @date    Feb 7, 2024
  * @brief   ECE 362 Lab 7 student template
  ******************************************************************************
*/

/*******************************************************************************/

// Fill out your username!  Even though we're not using an autotest, 
// it should be a habit to fill out your username in this field now.
const char* username = "sveeredh";

/*******************************************************************************/ 

#include "stm32f0xx.h"
#include <stdint.h>

void internal_clock();

void setup_adc(void) {
    RCC->AHBENR |= RCC_AHBENR_GPIOAEN;
    GPIOA->MODER &= ~(0xC);
    GPIOA->MODER |= 0xC;
    RCC->APB2ENR |= RCC_APB2ENR_ADCEN;
    ADC1->CFGR2 &= ~ADC_CFGR2_CKMODE;
    RCC->CR2 |= RCC_CR2_HSI14ON;
    while(!(RCC->CR2 & RCC_CR2_HSI14RDY));
    ADC1->CR |= ADC_CR_ADEN;
    while(!(ADC1->ISR & ADC_ISR_ADRDY));
    ADC1->CHSELR |= ADC_CHSELR_CHSEL1;
    while(!(ADC1->ISR & ADC_ISR_ADRDY));

}

void setup_dma(void) {
    RCC->AHBENR |= RCC_AHBENR_DMA1EN;
    DMA1_Channel5->CCR &= ~DMA_CCR_EN; 

    DMA1_Channel5->CMAR = //Base address of the memory area from/to which the data will be read/written.

    DMA1_Channel5->CPAR = (uint32_t)(&GPIOA->ODR);//Peripheral address
    DMA1_Channel5->CNDTR = 1; //Number of data to transfer
    DMA1_Channel5->CCR &= ~DMA_CCR_DIR; //DIRECTION: read from peripheral
    DMA1_Channel5->CCR |= DMA_CCR_MINC;
    DMA1_Channel5->CCR |= DMA_CCR_MSIZE_0 | DMA_CCR_PSIZE_0 | DMA_CCR_CIRC;



}

void enable_dma(void) {
    DMA1_Channel5->CCR |= DMA_CCR_EN; 
}


#define BCSIZE 32
#define THRESHOLD 1000
int bcsum = 0;
int boxcar[BCSIZE];
int bcn = 0;
uint32_t volume = 2048;
uint32_t last_peak_time = 0;
uint32_t peak_time = 0;
uint32_t bpm = 0;


void TIM2_IRQHandler(void){
    TIM2->SR &= ~TIM_SR_UIF;
    ADC1->CR |= ADC_CR_ADSTART;
    while(!(ADC1->ISR & ADC_ISR_EOC));

    bcsum -= boxcar[bcn];
    bcsum += boxcar[bcn] = ADC1->DR;
    bcn += 1;
    if (bcn >= BCSIZE)
        bcn = 0;
    volume = bcsum / BCSIZE;

    if (volume > THRESHOLD) {
        peak_time = HAL_get_tick();
        if (last_peak_time > 0) {
            bpm = 60000 / (peak_time - last_peak_time);  
        }
        last_peak_time = peak_time;
    }

    //display bpm function call here
}

void init_tim2(void) {

    RCC->APB1ENR |= RCC_APB1ENR_TIM2EN;
    
    /*sample rate of 2000 Hz*/
    TIM2->PSC = 2400 - 1; 
    TIM2->ARR = 10 - 1;
    
    TIM2->DIER |= TIM_DIER_UIE;
    NVIC->ISER[0] |= 1 << 15;
    TIM2->CR1 |= TIM_CR1_CEN;

}

/************************************************************************************************************* */

#define SHELL

void init_usart5() {
    // enable rcc clocks
    RCC->AHBENR |= RCC_AHBENR_GPIOCEN;
    RCC->AHBENR |= RCC_AHBENR_GPIODEN;

    // configure pc12 for usarts_tx
    GPIOC->MODER &= ~GPIO_MODER_MODER12_Msk;
    GPIOC->MODER |= GPIO_MODER_MODER12_1;
    GPIOC->AFR[1] &= ~GPIO_AFRH_AFSEL12_Msk;
    GPIOC->AFR[1] |= 2 << GPIO_AFRH_AFSEL12_Pos;

    // configure pd2 for usarts_rx
    GPIOD->MODER &= ~GPIO_MODER_MODER2_Msk;
    GPIOD->MODER |= GPIO_MODER_MODER2_1;
    GPIOD->AFR[0] &= ~GPIO_AFRL_AFSEL2_Msk;
    GPIOD->AFR[0] |= 2 << GPIO_AFRL_AFSEL2_Pos;

    // rcc clock to usart5
    RCC->APB1ENR |= RCC_APB1ENR_USART5EN;
    
    // configure usart5
    USART5->CR1 &= ~USART_CR1_UE;  // disable (turn off ue bit)
    USART5->CR1 &= ~USART_CR1_M;   // 8 data bits
    USART5->CR2 &= ~USART_CR2_STOP;  // 1 stop bit
    USART5->CR1 &= ~USART_CR1_PCE;   // no parity
    USART5->CR1 &= ~USART_CR1_OVER8; // 16x oversampling
    USART5->BRR = 0x1A1; // 115200 baud
    USART5->CR1 |= USART_CR1_TE | USART_CR1_RE;  // transmitter and receiver enable
    USART5->CR1 |= USART_CR1_UE;  // enable usart

    // wait for te and re bits to be acknowledged
    while(!(USART5->ISR & (USART_ISR_TEACK | USART_ISR_REACK)));
}

#ifdef SHELL
#include "commands.h"
#include <stdio.h>

#include <stdio.h>
#include "fifo.h"
#include "tty.h"

#define FIFOSIZE 16
char serfifo[FIFOSIZE];
int seroffset = 0;

void enable_tty_interrupt(void) {
    
    USART5->CR1 |= USART_CR1_RXNEIE;  // rxne interrupt enable
    USART5->CR3 |= USART_CR3_DMAR;    // dma mode for reception enable
    NVIC->ISER[0] = 1 << USART3_8_IRQn;  // usart5 interrupt in nvic enable
    
    RCC->AHBENR |= RCC_AHBENR_DMA2EN;
    DMA2->CSELR |= DMA2_CSELR_CH2_USART5_RX;
    DMA2_Channel2->CCR &= ~DMA_CCR_EN;  // disable dma channel
    DMA2_Channel2->CMAR = (uint32_t)serfifo; // cmar
    DMA2_Channel2->CPAR = (uint32_t)&USART5->RDR; // cpar
    DMA2_Channel2->CNDTR = FIFOSIZE; // cndtr
    DMA2_Channel2->CCR &= ~DMA_CCR_DIR; // direction of copying
    DMA2_Channel2->CCR &= ~(DMA_CCR_HTIE | DMA_CCR_TCIE); // disable total and half completion interrupt 
    DMA2_Channel2->CCR &= ~(DMA_CCR_MSIZE | DMA_CCR_PSIZE); // msize and psize
    DMA2_Channel2->CCR |= DMA_CCR_MINC;  // minc
    DMA2_Channel2->CCR &= ~DMA_CCR_PINC;  // pinc
    DMA2_Channel2->CCR |= DMA_CCR_CIRC;  // circular mode
    DMA2_Channel2->CCR |= DMA_CCR_PL_1 | DMA_CCR_PL_0;  //highest priority
    DMA2_Channel2->CCR &= ~DMA_CCR_MEM2MEM;  // disable mem2mem mode
    DMA2_Channel2->CCR |= DMA_CCR_EN;  // dma enable
}

// Works like line_buffer_getchar(), but does not check or clear ORE nor wait on new characters in USART
char interrupt_getchar() {
    while(!fifo_newline(&input_fifo)) {
        asm volatile ("wfi");
    }
    char c = fifo_remove(&input_fifo);
    return c;
}

int __io_putchar(int c) {
    // check newline
    if (c == '\n') {
        while(!(USART5->ISR & USART_ISR_TXE));
        USART5->TDR = '\r';
    }
    while(!(USART5->ISR & USART_ISR_TXE));
    USART5->TDR = c;
    return c;
}

int __io_getchar(void) {
    return interrupt_getchar();
}

void USART3_8_IRQHandler(void) {
    while(DMA2_Channel2->CNDTR != sizeof serfifo - seroffset) {
        if (!fifo_full(&input_fifo))
            insert_echo_char(serfifo[seroffset]);
        seroffset = (seroffset + 1) % sizeof serfifo;
    }
}

void init_spi1_slow(void) {
    RCC->AHBENR |= RCC_AHBENR_GPIOBEN;
    
    // pb3 (SCK), pb4 (MISO), pb5 (MOSI)
    GPIOB->MODER &= ~(GPIO_MODER_MODER3_Msk | GPIO_MODER_MODER4_Msk | GPIO_MODER_MODER5_Msk);
    GPIOB->MODER |= GPIO_MODER_MODER3_1 | GPIO_MODER_MODER4_1 | GPIO_MODER_MODER5_1;
    
    GPIOB->AFR[0] &= ~(GPIO_AFRL_AFRL3_Msk | GPIO_AFRL_AFRL4_Msk | GPIO_AFRL_AFRL5_Msk);

    // enable spi1 clock
    RCC->APB2ENR |= RCC_APB2ENR_SPI1EN;
    SPI1->CR1 = 0;
    SPI1->CR1 |= SPI_CR1_MSTR;              // master mode
    SPI1->CR2 = SPI_CR2_DS_2 | SPI_CR2_DS_1 | SPI_CR2_DS_0; // 8-bit data size (0b111)
    SPI1->CR1 |= SPI_CR1_SSM | SPI_CR1_SSI; // software slave management
    SPI1->CR2 |= SPI_CR2_FRXTH;             // fifo
    SPI1->CR1 |= SPI_CR1_SPE;               // spi enable
}

void enable_sdcard(void) {
    GPIOB->BSRR = GPIO_BSRR_BR_2;  // pb2 low
}

void disable_sdcard(void) {
    GPIOB->BSRR = GPIO_BSRR_BS_2;  // pb2 high
}

void init_sdcard_io(void) {
    init_spi1_slow();
    
    RCC->AHBENR |= RCC_AHBENR_GPIOBEN;
    GPIOB->MODER &= ~GPIO_MODER_MODER2_Msk;
    GPIOB->MODER |= GPIO_MODER_MODER2_0;
    
    disable_sdcard();
}

void sdcard_io_high_speed(void) {
    SPI1->CR1 &= ~SPI_CR1_SPE;
    
    // set to 12mhz
    SPI1->CR1 &= ~SPI_CR1_BR_Msk;
    SPI1->CR1 |= (1 << SPI_CR1_BR_Pos);
    
    SPI1->CR1 |= SPI_CR1_SPE;
}

void init_lcd_spi(void) {
    RCC->AHBENR |= RCC_AHBENR_GPIOBEN;
    
    GPIOB->MODER &= ~(GPIO_MODER_MODER8_Msk | GPIO_MODER_MODER11_Msk | GPIO_MODER_MODER14_Msk);
    GPIOB->MODER |= GPIO_MODER_MODER8_0 | GPIO_MODER_MODER11_0 | GPIO_MODER_MODER14_0;
    
    GPIOB->BSRR = GPIO_BSRR_BS_8 | GPIO_BSRR_BS_11 | GPIO_BSRR_BS_14;
    
    init_spi1_slow();
    sdcard_io_high_speed();
}

int main() {
    internal_clock();
    init_usart5();
    enable_tty_interrupt();
    setbuf(stdin,0);
    setbuf(stdout,0);
    setbuf(stderr,0);
    command_shell();
    return 0;
}

#endif 


//Parv's code: adc and timer isr setup to sample at 2000 Hz
/************************************************************************************************************* */


